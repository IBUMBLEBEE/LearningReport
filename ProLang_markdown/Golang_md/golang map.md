# Map

- map 相关：

1. 散列表是设计精妙、用途广泛的数据结构之一。
2. 拥有键值对元素的无序集合。
3. map 中的所有的键类型都拥有相同的数据类型，同时所有的值也都拥有相同的数据类型，但是键值的数据类型可以不一样。
4. 内置函数 make 可以用来创建一个 map（未初始化）；也可以使用 map 字面量来新建一个带初始键值对元素的字典；新的空 map 的另一种表达式是：map([string]int{})。
5. 内置函数 delete 函数来从字段中根据键移除一个元素。
6. map 使用给定的键来查找元素，当对应元素不存在时，就会返回值类型的零值。
7. 快捷赋值方式（如 x+=y 和 x++）对 map 的元素同样适用。
8. map 的元素不是一个变量，不能通过取地址操作获得内存地址。
9. 我们无法获得 mao 元素的地址的另一个原因是 map 的增长可能会导致已有的元素得到新的存储位置，这样就可能使得地址无效。
10. map 中的元素的迭代顺序是不固定的，不同的实现方法会会使用不同的散列算法，使得得到不同的元素顺序。
11. 这个是有意为之，这样可以使得程序在不同的散列算法实现下变得健壮。

    ```golang
    import "sort"

    args := map([string]int) {
        "alice": 33,
        "grey": 44,
    }

    var names []string
    for name := range ages {  // 当range map是，不想要第二个值，可以直接省略
        names = append(names, name)
    }
    sort.Strings(names)
    for _, name := range names {  // 当range 返回的是两个值时，不需要第一个值（元素索引）是，使用_ 来忽略一个变量
        fmt.Printf("%s\t%d\n", name, ages[name])
    }
    ```

12. 设置元素之前，必须初始化 map。
13. 通过下标的方式访问 map 中的元素总是会有值。如果 map 键存在，就会返回对应的值；如果元素的键不存在，就会返回值类型的零值。
14. 通过下标的方式访问 map 中的元素输出两个值，第二个值是一个布尔值，用来报告该元素是否存储在。这个布尔变量一般叫做 ok，尤其是它在 if 条件判断中的时候。
15. 和 slice 一样，map 不可以比较，唯一合法的比较就是和 nil 比较。
16. 为了判断两个 map 是否拥有相同的键值，必须写一个循环。
17. 注意我们如何使用!ok 来区分”元素不存在“和”元素存在但是值为 0“的情况。

    ```golang
    func equal(x, y map[string]int) bool {
        if len(x) != len(y) {
            return false
        }
        for k, xv := range x {
            // 当map x中的键在y中可以取到的元素时，!ok为false，map y 的元素值与map x 的元素值相等，yv != xv为false
            //
            if yv, ok := y[k]; !ok || yv != xv {
                return false
            }
        }
        return true
    }
    ```

18. 有时候，我们需要一个 map 并且需求它的键是 slice，但是因为 map 的键必须是可以比较的，所以这个功能无法直接实现。然而，我们可以分两步来做。首先，定义一个帮助函数 k，将每一个键都映射到字符串，当且仅当 x 和 y 相等的时候，我们才认为 k(x) == k(y)。然后，就可以创建一个 map，map 的键是字符串类型，在每个键元素被访问的时候，调用这个帮助函数。
